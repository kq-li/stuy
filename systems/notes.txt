09/14/2016
  Aim: Variables are the spice of life.
  Do Now: What are the primitive variable types in Java?

  C primitives:
  int         4B        -2^31 to 2^31 - 1    ~2.1b
  short       2B        -2^15 to 2^15 - 1    32768
  long        8B        -2^63 to 2^63 - 1    big
  char        1B        -2^7 to 2^7 - 1      256

  float       4B        7 digits of precision
  double      8B        14 digits of precision

  All primitives in C are numeric - the only differences between them are floating
  point vs integer and size of variable.

  Size can be platform-dependent.
  sizeof(<TYPE>) can be used to find the size in bytes
    ex: sizeof(int)

09/13/2016
  Aim: Don't forget to read the fine print
  Do Now: What is the smallest variable type that could be used to store the
          following values (using standard sizes)?

  1) 5 - char
  2) -30,000 - long
  3) 255 - int
  4) 5,000,000,000 - long

  C Primitive Variable Types
    All boolean values are numbers
      0 -> false
      anything else -> true

  printf
    The most important C function!

    Prints formatted strings

    printf(<string literal>, [<var1>, <var2>, ...])

09/19/2016
  Aim: A vast array of possibilities
  Do Now: Turn to your neighbors and discuss the things that came up
          while you were working on the euler assignment. What did you
          find surprising or confusing, helpful or harmful?

09/20/2016
  Aim: What's the point of it all?
  Do Now: Declare a regular variable and an array in a C program.
          Then print out the size of each.

  Pointers - Now the fun really starts
    Variables designed to store memory addresses (think references in java)
    * is used to declare a variable as a pointer type
      int *p
      double *q
      char *r
      
09/21/2016
  Aim: Try not to hurt yourself, the point is sharp.

  More Pointer Fun
    Pointer arithmetic
      Declaring a pointer as a specific type allows you to add to and subtract
      from the pointer by the size of its associated type.

        int *ip;
        long *lp;
        ip++; // adds 4 to ip
        lp++; // adds 8 to lp

      Pointer arithmetic only works with + and - of integers.
    Array variables are immutable pointers.

    De-reference
      * is also used as the de-reference operator. It accesses the value at the
      memory location stored in a pointer

        int i = 5;
        int *ip = &i;
        *ip++; // this sets i to 6

      Dereferencing takes priority over most operations, barring only ++/--.

09/22/2016
  Aim: How to write functioning code
  Do Now: Write a c program with a simple function.
          Call the function in main()

  Writing functions
    Function headers:
      <return type> <name>(<parameters>)

    You must declare a function before you use it.

    This can be done in a few ways:
      Write the entire function at the top of your code,
      making sure to keep the order correct.

      Write the function headers at the top of your code,
      and provide the full definition later.

      Put all the function headers in a separate header
      file (file extension .h). Then include that file in
      your .c file and provide the definitions there.

    All C functions are "pass by value"
      A parameter is a copy of the variable passed into
      the function. The original variable is not touched.

09/23/2016
  Aim: Time to stop stringing you along.
  Do Now: Create a char array of a reasonable size.
          Print it out using %s as the formatting character.

  C strings
    Strings are character arrays that end with a null character ('', 0, '\0')

    The terminating null character is a convention, but string functions
    will not work correctly without it.

    When you create a literal string using "", an immutable string is created
    in memory, so if you create the same string literal again, the computer does
    not need to allocate more memory. These strings are always null terminated.

  Valid ways to declare strings:
    char s[256];
      Normal array declaration, allocates 256 bytes, nothing
      is set automatically.

    char s[256] = "Imagine";
      Allocates 256 bytes. Creates the immutable string "Imagine" and then
      copies it (including the terminating null) into the array.

    char s[] = "Tuesday";
      Allocates 8 bytes. Creates the immutable string "Tuesday" and then
      copies it (including the terminating null) into the array.

    char *s = "Mankind";
      Creates the immutable string "Mankind", and returns a pointer to that
      string. Since the pointer is to an immutable piece of memory, you
      cannot modify things created in this way.

09/26/2016
  Aim: A string of functions.
  Do Now: Write a function that returns the length of a string,
          assuming it is null-terminated.

09/29/2016
  Aim: Make it so

  Make
    Create compiling instructions and setup dependencies

    Standard name for the file is makefile

    Syntax:
      <target>: <dependencies>
      <tab><rules>

10/04/2016
  Aim: If these files won't behave, we'll have to separate them!

  Separate compilation
    You can combine multiple c files into a c program by including them all in
    one gcc command.
    
      gcc test.c string.c foo.c woohoo.c

    You cannot have duplicate function or global variable names across the files.

  gcc -c
    Generate a compiled "object", or .o file

    Does not create a fully functional program, but is compiled code

    .o files can be linked with .c files through gcc

10/05/2016
  Aim: malloc & free: the dynamic duo!

  0: malloc, free
  1: calloc, realloc

  malloc(int x)
    Allocates x bytes of memory (from the heap).

  calloc(int n, int x)
    Allocates n * x bytes of memory, ensuring that each part is set to 0.

  realloc(void *p, int x)
    Changes the amount of memory allocated to a given block.

    p must be a pointer to the beginning of an allocated block of memory,
    but it does not have to be the original pointer.

  free(void *p)
    Releases dynamically allocated memory.

  
