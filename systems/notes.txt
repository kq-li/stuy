09/14/2016
  Aim: Variables are the spice of life.
  Do Now: What are the primitive variable types in Java?

  C primitives:
  int         4B        -2^31 to 2^31 - 1    ~2.1b
  short       2B        -2^15 to 2^15 - 1    32768
  long        8B        -2^63 to 2^63 - 1    big
  char        1B        -2^7 to 2^7 - 1      256

  float       4B        7 digits of precision
  double      8B        14 digits of precision

  All primitives in C are numeric - the only differences between them are floating
  point vs integer and size of variable.

  Size can be platform-dependent.
  sizeof(<TYPE>) can be used to find the size in bytes
    ex: sizeof(int)

09/13/2016
  Aim: Don't forget to read the fine print
  Do Now: What is the smallest variable type that could be used to store the
          following values (using standard sizes)?

  1) 5 - char
  2) -30,000 - long
  3) 255 - int
  4) 5,000,000,000 - long

  C Primitive Variable Types
    All boolean values are numbers
      0 -> false
      anything else -> true

  printf
    The most important C function!

    Prints formatted strings

    printf(<string literal>, [<var1>, <var2>, ...])

09/19/2016
  Aim: A vast array of possibilities
  Do Now: Turn to your neighbors and discuss the things that came up
          while you were working on the euler assignment. What did you
          find surprising or confusing, helpful or harmful?

09/20/2016
  Aim: What's the point of it all?
  Do Now: Declare a regular variable and an array in a C program.
          Then print out the size of each.

  Pointers - Now the fun really starts
    Variables designed to store memory addresses (think references in java)
    * is used to declare a variable as a pointer type
      int *p
      double *q
      char *r
      
09/21/2016
  Aim: Try not to hurt yourself, the point is sharp.

  More Pointer Fun
    Pointer arithmetic
      Declaring a pointer as a specific type allows you to add to and subtract
      from the pointer by the size of its associated type.

        int *ip;
        long *lp;
        ip++; // adds 4 to ip
        lp++; // adds 8 to lp

      Pointer arithmetic only works with + and - of integers.
    Array variables are immutable pointers.

    De-reference
      * is also used as the de-reference operator. It accesses the value at the
      memory location stored in a pointer

        int i = 5;
        int *ip = &i;
        *ip++; // this sets i to 6

      Dereferencing takes priority over most operations, barring only ++/--.

09/22/2016
  Aim: How to write functioning code
  Do Now: Write a c program with a simple function.
          Call the function in main()

  Writing functions
    Function headers:
      <return type> <name>(<parameters>)

    You must declare a function before you use it.

    This can be done in a few ways:
      Write the entire function at the top of your code,
      making sure to keep the order correct.

      Write the function headers at the top of your code,
      and provide the full definition later.

      Put all the function headers in a separate header
      file (file extension .h). Then include that file in
      your .c file and provide the definitions there.

    All C functions are "pass by value"
      A parameter is a copy of the variable passed into
      the function. The original variable is not touched.

09/23/2016
  Aim: Time to stop stringing you along.
  Do Now: Create a char array of a reasonable size.
          Print it out using %s as the formatting character.

  C strings
    Strings are character arrays that end with a null character ('', 0, '\0')

    The terminating null character is a convention, but string functions
    will not work correctly without it.

    When you create a literal string using "", an immutable string is created
    in memory, so if you create the same string literal again, the computer does
    not need to allocate more memory. These strings are always null terminated.

  Valid ways to declare strings:
    char s[256];
      Normal array declaration, allocates 256 bytes, nothing
      is set automatically.

    char s[256] = "Imagine";
      Allocates 256 bytes. Creates the immutable string "Imagine" and then
      copies it (including the terminating null) into the array.

    char s[] = "Tuesday";
      Allocates 8 bytes. Creates the immutable string "Tuesday" and then
      copies it (including the terminating null) into the array.

    char *s = "Mankind";
      Creates the immutable string "Mankind", and returns a pointer to that
      string. Since the pointer is to an immutable piece of memory, you
      cannot modify things created in this way.

09/26/2016
  Aim: A string of functions.
  Do Now: Write a function that returns the length of a string,
          assuming it is null-terminated.

09/29/2016
  Aim: Make it so

  Make
    Create compiling instructions and setup dependencies

    Standard name for the file is makefile

    Syntax:
      <target>: <dependencies>
      <tab><rules>

10/05/2016
  Aim: If these files won't behave, we'll have to separate them!

  Separate compilation
    You can combine multiple c files into a c program by including them all in
    one gcc command.
    
      gcc test.c string.c foo.c woohoo.c

    You cannot have duplicate function or global variable names across the files.

  gcc -c
    Generate a compiled "object", or .o file

    Does not create a fully functional program, but is compiled code

    .o files can be linked with .c files through gcc

10/06/2016
  Aim: malloc & free: the dynamic duo!

  0: malloc, free
  1: calloc, realloc

  malloc(int x)
    Allocates x bytes of memory (from the heap).

  calloc(int n, int x)
    Allocates n * x bytes of memory, ensuring that each part is set to 0.

  realloc(void *p, int x)
    Changes the amount of memory allocated to a given block.

    p must be a pointer to the beginning of an allocated block of memory,
    but it does not have to be the original pointer.

  free(void *p)
    Releases dynamically allocated memory.
    
10/07/2016
  Aim: Structured programming

  void *
    The dynamic memory functions deal in arbitrary blocks of memory.
    There is no regular type associated with the block.

    void * is considered to be a pointer to a 1 byte block of memory,
    so pointer arithmetic will be based on 1.

    Whenever possible you should typecast void * values to the appropriate type.

      int *ip;
      ip = (int *) malloc(5 * sizeof(int));

  struct
    A collection of values in a single data type

    struct {
      int a;
      char x;
    } s;

      Here, s is a variable of type
        struct {
          int a;
          char x;
        }.

10/11/2016
  Aim: Get Dem Bugs
  Do Now: What's wrong with this function?

  struct node *insert_front(struct node *n, int i) {
    struct node new;

    new.i = i;
    new.next = n;

    return &new;
  }

  
  typedef
    Provide a new name for an existing data type.

    typedef <real type> <new name>;
      typedef unsigned long size_t;
      typedef struct {
        int a;
        char x;
      } bar;

    gdb - GNU Debugger
      Allows you to get detailed information about a program while running.

      Add the -g flag to gcc to generate debugging symbols.

      Basic usage: $ gdb <program>

      Commands in gdb shell
        run: runs the program until it ends/crashes
        list: show the lines of code run around a crash
        print <var>: print a variable
        backtrace: show the current stack

10/13/2016
  Aim:

  valgrind to find memory errors

10/18/2016
  Aim: C, the ultimate hipster, using # decades before it was cool

  #
    Used to provide preprocessor instructions.
    These directives are handled before the compiler really kicks in.

    #include <<library>> OR #include "<library>"
      Link libraries to your code.

    #define <name> <value>
      Replace all occurrences of NAME with VALUE

      #define TRUE 1

      #define SQUARE(x) x * x
      ...
      int y = SQUARE(9); --> int y = 9 * 9;

    #ifndef <identifier>
    <code>
    #endif
      If the identefier has been defined, itnore all the code
      up until the endif statement.

10/19/2016
  Aim: A bit of wisdom

  Do Now: >> and << are binary operators, test them out with small integers
          and see if you can figure out what they do.
      
  Bitwise operators
    << left shift, >> right shift
      Move all bits to the left/right.
      Left shift pads with 0s, right shift truncates.
      Left and right shift do not overflow end bits into adjacent memory.

    ~ negation
      Flip every bit.

    | or
      Perform or for each pair of bits in (a, b).

    & and
      Perform and for each pair of bits in (a, b).

    ^ xor
      Perform xor for each pair of bits in (a, b).

10/21/2016
  Aim: File this under useful information.

  Do Now: What are the different kinds of file permissions?

  File permissions
    3 types:
      read, write, execute

    Permissions can be represented as 3 digit binary or 1 digit octal numbers.
      100 = 4 -> read-only
      111 = 7 -> read, write, execute

    There are three permission areas: user, group, others.
      Each can have its own permissions.
        644 -> user: read+write, group: read, other: read

  File Table
    A list of all files used by a program while it is running.
    
    Contains basic information like the file's location and size.
      
    The file table has a limited size (power of 2), usually 256.
      The size is returned by getdtablesize()

    Each file is given an integer index, starting at 0; this is referred
    to as the file descriptor.

    There are three files always open in the table:
      0 or STDIN_FILENO: stdin
      1 or STDOUT_FILENO: stdout
      2 or STDERR_FILENO: stderr

10/24/2016
  Aim: Opening up a world of possibilities.

  Do Now: In your table pairs, look at your computer number and mod it by 2.
          Then look up the following functions and describe them to your buddy.

          0. open/close
          1. read/write


  open(<path>, <flags>, <mode>) -  <fcntl.h>
    Add a file to the file table and returns its file descriptor.

    If open fails, it retursn -1, storing extra error info (code) in errno.

      errno is an int variable that can be found in <errno.h>; using strerror
      (in <string.h>) on errno will return a string description of the error.

    mode
      Only used when creating a file. Set the new file's permissions using a
      3 digit octal number (leading 0).

    flags
      Determine what you plan to do with the file.

      Use the following constants:
        O_RDONLY
        O_WRONLY
        O_RDWR
        O_APPEND
        O_TRUNC
        O_CREAT
        O_EXCL (Combined with O_CREAT, returns an error if the file exists

      Each flag is a number - to combine flags use bitwise or.
        O_WRONLY = 1                    00000001
        O_APPEND = 8                    00001000
        O_WRONLY | O_APPEND = 9         00001001

  close(<file>) - <unistd.h>
    Remove a file from the file table.

    Returns 0 if successful, returns -1 and sets errno otherwise.

10/25/2016
  Aim: Read your writes!

  Do Now: Write a C program that creates a new file. Give the file read and
          write permissions to each permission area.

          Run ls -l to check the permissions.

  umask(<mask>) - <sys/stat.h>
    Set the file creation permission mask.

    By default, created files are not given the exact permissions provided in
    the mode argument to open. Some permissions are automatically shut off.

    Umask is applied by using bitwise negation on the mask, then bitwise and
    on it and the mode
      new_permissions = ~mask & mode

    Mask is octal number
      0022 is default mask
      0000 allows any permissions to be set

  read(<file descriptor>, <buffer>, <amount>) - <unistd.h>
    Read in data from a file.

    read(fd, buff, n)
      Reads n bytes from the fd's file and puts that data into buff.
      Returns the number of bytes actually read. Returns -1 and sets errno
      if unsuccessful.

    Buffer must be a pointer.

  write(<file descriptor>, <buffer>, <amount>) - <unistd.h>
    Writes data to a file.

    write(fd, buff, n)
      Writes n bytes from buff into fd's file.
      Returns the number of bytes actually written. Returns -1 and sets
      errno if unsuccessful.

    Buffer must be a pointer.
      


    
      
  
