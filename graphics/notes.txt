02/01/2017
	Aim: Bits o' pixels?

	How would you represent color data if you only had the following amount of
	space for each pixel?

	1. 1 bit  - 1 bit for color
	2. 2 bits - 1 bit for color, 1 bit for intensity
	3. 3 bits - 1 bit for each color (RGB)
	4. 4 bits - 1 bit for each color (RGB), 1 bit for intensity
	5. 6 bits - 2 bits for each color (RGB); 1 bit for color, 1 bit for intensity

	Color depth - number of bits used per pixel

	Image File Formats
		Lossless vs. lossy, compressed vs. uncompressed

		JPG - compressed, lossy
		PNG - compressed, lossless
		BMP - uncompressed, lossless
		TIFF - uncompressed, lossless
		RAW - uncompressed, lossless
		GIF - uncompressed, lossless
		
02/02/2017
	Aim:

	RUn Length Encoding
		GGGRPPPP -> 3G1R4P (2 bytes shorter)

	Rasters vs Vectors
		Raster: data corresponds to pixels
		Vector: image data encoded as list of commands

	Net PBM
		Family of formats

		We will use .ppm
			All whitespace is the same

			Header
				P3
				XRES YRES
                Scale factor

			Pixel Data
				3 numbers, 0-255 (RGB)

02/06/2017
    Aim: Bresenham's Line Algorithm

    y = mx + b
    y = (Δy/Δx)x + b
    Δyx - Δxy + Δxb
    A = Δy
    B = -Δx
    C = Δxb
    Ax + By + C = 0
    f(x, y) = Ax + By + C

    f(x, y) = 0: (x, y) on the line
    f(x, y) < 0: (x, y) above the line
    f(x, y) > 0: (x, y) below the line
    f(x, y) ~ distance from (x, y) to line

    0 < m <= 1: only look at pixel to right and upper right

02/07/2017
    Aim: Bresenham's Line Algorithm, continued

    Evaluate f at both pixels -> inefficient
    Evaluate f at midpoint
        If midpoint above line, plot bottom pixel
        If midpoint below line, plot top pixel

    Two pixels: (x + 1, y), (x + 1, y + 1)
    Midpoint: (x + 1, y + 0.5)
    f(x + 1, y + 0.5) < 0: midpoint above line, plot bottom pixel
    f(x + 1, y + 0.5) > 0: midpoint below line, plot top pixel
    f(x + 1, y + 0.5) = 0: plot either, be consistent


    Pseudocode
        y = y0

        for x: x0 to x1
            plot(x, y)
            
            d = f(x + 1, y + 0.5)

            if (d > 0)
                y++

            x++

02/08/2017
    Aim: Optimization

    f(x, y) = Ax + By + C
            = Δyx - Δxy + Δxb

    (x0, y0) -> (x1, y1)

    Problems
        Expensive "f" calculations
        Floating point calculations

    Octant 1 Algorithm
        x = x0
        y = y0
        d = 2A + B

        while (x <= x1)
            plot(x, y)

            if (d > 0)
                y++
                d += 2B

            x++
            d += 2A

02/13/2017
    Octant 8 Algorithm
        x = x0
        y = y0
        d = 2A - B

        while (x <= x1)
            plot(x, y)

            if (d < 0)
                y--
                d -= 2B

            x++
            d += 2A

    Octant 2 Algorithm
        x = x0
        y = y0
        d = A + 2B

        while (y <= y1)
            plot(x, y)

            if (d < 0)
                x++
                d += 2A

            y++
            d += 2B

    Octant 7 Algorithm
        x = x0
        y = y0
        d = A - 2B

        while (y >= y1)
            plot(x, y)

            if (d > 0)
                x++
                d += 2A

            y--
            d -= 2B

02/16/2017
    To allow efficient transformations, store images as a list of edges.
    
    Each pair of points in the list will define an edge.
        [P0, P1, P2, P3, P4, ...] defines edges P0P1, P1P2, P2P3, P3P4, etc.

    Call draw-line with consecutive points in the list.

    Transformations can be applied to the edge list before drawing.

    Storing the edge list
        Each point has 3 floating point components x, y, z.

        Points can be stored in a 4 x n matrix.
            [  x0  x1  x2  ...  xn  ]
            [  y0  y1  y2  ...  yn  ]
            [  z0  z1  z2  ...  zn  ]
            [  1.0 1.0 1.0 ...  1.0 ]


    Matrix Math Review
        Scalar multiplication
            5 x [ a b ] = [ 5a 5b ]
                [ c d ] = [ 5c 5d ]
                
        Matrix multiplication
            A: m x n matrix
            B: n x p matrix
            AB: m x p matrix
            
            Columns in first must match rows in second.

            In order to multiply a transformation matrix T with an edge matrix,
            T must be a 4 x 4 matrix.

            [ a b c ] [ g h ] = [ (ag + bi + ck) (ah + bj + cl) ]
            [ d e f ] [ i j ]   [ (dg + ei + fk) (dh + ej + fl) ]
                      [ k l ]

            (AB)_ij = Σ(A_ik x B_kj)

        Multiplicative identity
            I_n is the n x n identity matrix

            Given M, an m x n matrix I_m * M = M = M * I_n.

            If m = n, then multiplication by the identity is commutative.

            I is always square, with the principal diagonal containing all
            1s and the rest of the matrix all 0s.

            I_4 = [ 1 0 0 0 ]
                  [ 0 1 0 0 ]
                  [ 0 0 1 0 ]
                  [ 0 0 0 1 ]
            
        Inverse
    
03/01/2017
    Transformations
        Translation
                       T(a, b, c)
            (x, y, z) -----------> (x + a, y + b, z + c)

            [ 1 0 0 a ] [ x ] = [ x + a ]
            [ 0 1 0 b ] [ y ]   [ y + b ]
            [ 0 0 1 c ] [ z ]   [ z + c ]
            [ 0 0 0 1 ] [ 1 ]   [   1   ]
            
        Scale
                       S(a, b, c)
            (x, y, z) -----------> (ax, by, cz)

            [ a 0 0 0 ] [ x ] = [ ax ]
            [ 0 b 0 0 ] [ y ]   [ by ]
            [ 0 0 c 0 ] [ z ]   [ cz ]
            [ 0 0 0 1 ] [ 1 ]   [  1 ]
        
        Rotation
                       R(A, axis)
            (x, y, z) ---------------> (?, ?, ?)

            Rotate (x, y, 0) at angle B from x-axis A around the z-axis

                x = r cos B
                y = r sin B
                x1 = r cos (B + A)
                   = r cos B cos A - r sin B sin A
                   = x cos A - y sin A
                y1 = r sin (B + A)
                   = r sin B cos A + r cos B sin A
                   = x sin A + y cos A

                           R(A, z)
                (x, y, z) --------> (x cos A - y sin A, x sin A + y cos A, z)

                [ (cos A) (-sin A) 0 0 ] [ x ] = [ x cos A - y sin A ]
                [ (sin A)  (cos A) 0 0 ] [ y ]   [ x sin A + y cos A ]
                [    0        0    1 0 ] [ z ]   [         z         ]
                [    0        0    0 1 ] [ 1 ]   [         1         ]


            Rotate (0, y, z) at angle B from y-axis A around the x-axis

                y = r cos B
                z = r sin B
                y1 = r cos (B + A)
                   = r cos B cos A - r sin B sin A
                   = y cos A - z sin A
                z1 = r sin (B + A)
                   = r sin B cos A + r cos B sin A
                   = y sin A + z cos A

                           R(A, x)
                (x, y, z) --------> (x, y cos A - z sin A, y sin A + z cos A)

                [ 1    0        0    0 ] [ x ] = [         x         ]
                [ 0 (cos A) (-sin A) 0 ] [ y ]   [ y cos A - z sin A ]
                [ 0 (sin A)  (cos A) 0 ] [ z ]   [ y sin A + z cos A ]
                [ 0    0        0    1 ] [ 1 ]   [         1         ]


            Rotate (x, 0, z) at angle B from x-axis A around the y-axis

                x = r cos B
                z = r sin B
                x1 = r cos (B + A)
                   = r cos B cos A - r sin B sin A
                   = x cos A - z sin A
                z1 = r sin (B + A)
                   = r sin B cos A + r cos B sin A
                   = x sin A + z cos A

                           R(A, y)
                (x, 0, z) --------> (x sin A + z cos A, 0, x cos A - z sin A)

                [ (sin A) 0  (cos A) 0 ] [ x ] = [ x sin A + z cos A ]
                [    0    1     0    0 ] [ y ]   [         y         ]
                [ (cos A) 0 (-sin A) 0 ] [ z ]   [ x cos A - z sin A ]
                [    0    0     0    1 ] [ 1 ]   [         1         ]

            Can compound any of the above with a translation to translate an
            arbitrary point

03/02/2017
    Combining Transformations
        S, T, R, E0
        S * E0 = E1
        D * E1 = E2
        T * E2 = E3

        E3 = T * D * S * E0
           = (T * D * S) * E0
